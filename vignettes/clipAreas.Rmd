---
title: "Clip based AOI"
vignette: >
  %\VignetteIndexEntry{pkgdown}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 6, 
  fig.height = 4
)

devtools::load_all()
library(leaflet)
library(sp)

col  = '#1c26a9'
col1 = '#212f3f'

icon.r <- awesomeIcons(
    icon='home',
    iconColor = col1,
    markerColor = "gray",
    library='fa')

icon.b <- awesomeIcons(
    icon='home',
    iconColor = col1,
    markerColor = 138,
    library='fa')

```

So far we've seen how `AOI` provides boundaries based on fiat or OSM defined space [here](./docs/articles/stateCounty.html).  This section hightlights the capabilities for generating flexiable boundaries. Boundaries are defined by a list ranging in size from 1 to 5 elements including:

  (1) A location   
  (2) A bounding box height and width (default is distance in miles) and
  (3) A location origin (default = 'center')   

All inputs must be provided as an ordered list. Examples for each element follows: 

# Building and AOI from Location, Bounding Boxes, and origins {.tabset .tabset-fade}

## Location

A **location** is the first input in a clip list, and can be given as a place name or numerice (lat/long) pair. Place names can be used on there own to query the OSM derived bounding box (equal to `geocode("XXX", bb = T)`)

```{r}
getAOI("Sacramento") %>% check(returnMap = T)
```

Latitude/Longitude pairs must be called with additional information.

## Bounding Box 

Once a location is specified, the next required values are a bounding box height and width. The first entry defines height and the second width, in the default case the provided location is treated as the centroid of the generated area.
  
```{r, message = FALSE}
# Get the 30 by 10 mile area centered on the National Water Center
getAOI(list("National Water Center, AL", 30, 10)) %>% check(returnMap = TRUE)

# Get the 10 by 30 mile area centered on (34,-118)
getAOI(list(34,-118, 10, 30)) %>% check(returnMap = TRUE)
```

## Origin

With a defined **location**, **height**, and **width**, the relationship of the box to the location is needed. By default bounding boxs are generated using the input location as a centroid. You can change this by adding a final argument to the **clip** list specifying where the location lies in reference to the box. Options include '*center*', '*lowerleft*', '*lowerright*', '*upperleft*', '*upperright*':
  
```{r, message = FALSE}
ucsb.c =  getAOI(list("UCSB", 10, 10, "center"))
ucsb.ul = getAOI(list("UCSB", 10, 10, "upperleft"))
ucsb.ur = getAOI(list("UCSB", 10, 10, "upperright"))
ucsb.ll = getAOI(list("UCSB", 10, 10, "lowerleft"))
ucsb.lr = getAOI(list("UCSB", 10, 10, "lowerright"))
```

```{r, echo = FALSE}

ucsb.c  = sf::st_transform(ucsb.c,  '+proj=longlat +datum=WGS84')
ucsb.ul = sf::st_transform(ucsb.ul, '+proj=longlat +datum=WGS84')
ucsb.ur = sf::st_transform(ucsb.ur, '+proj=longlat +datum=WGS84')
ucsb.ll = sf::st_transform(ucsb.ll, '+proj=longlat +datum=WGS84')
ucsb.lr = sf::st_transform(ucsb.lr, '+proj=longlat +datum=WGS84')

leaflet(option=leafletOptions(zoomControl= FALSE, minZoom = 10, maxZoom = 10)) %>%
  addProviderTiles(providers$CartoDB.Positron) %>% 
  addPolygons(data = ucsb.ul, fillColor = "transparent", color = col1, weight = 4, label ="upperleft") %>% 
  addPolygons(data = ucsb.ur, fillColor = "transparent", color = col1, weight = 4, label = "upperright") %>% 
  addPolygons(data = ucsb.ll, fillColor = "transparent", color = col1, weight = 4, label = "lowerleft") %>% 
  addPolygons(data = ucsb.lr, fillColor = "transparent", color = col1, weight = 4, label = "lowerright") %>% 
  addPolygons(data = ucsb.c,  fillColor = col1, color = col,  weight = 4, label = "center") %>% 
  addAwesomeMarkers(icon = icon.b, lat = 34.41396, lng = -119.8489, popup = 'UCSB')
```

## Modifying {.tabset .tabset-fade}

With the aim of flexible boundaries there is a final function aimed at modifing boudary locations, `modify`. Modify allows users to add a subtract a set distance from a known AOI. It is a convince wrapper around `sf::st_buffer()` that takes care of dealing with units. 

## Grow

```{r}
gg  = getAOI("Garden of the Gods")
gg_grow = getAOI("Garden of the Gods") %>% modify(1)
```

```{r, echo = FALSE}

gg = st_transform(gg,  '+proj=longlat +datum=WGS84')
ggm = st_transform(gg_grow,  '+proj=longlat +datum=WGS84')

leaflet(option=leafletOptions(zoomControl= FALSE, minZoom = 12, maxZoom = 12)) %>% addProviderTiles(providers$CartoDB.Positron) %>% 
  addPolygons(data = gg_grow, fillColor = 'transparent', color = 'red', weight = 4) %>% 
  addPolygons(data = gg,fillColor = col, color = col1, weight = 4)
```


## Shrink

```{r}
la = getAOI("Los Angeles")
la_shrink = getAOI("Los Angeles") %>% modify(-10) 
```


```{r, echo = FALSE, warning=F}
la = st_transform(la,  '+proj=longlat +datum=WGS84')
la_shrink = st_transform(la_shrink,  '+proj=longlat +datum=WGS84')

leaflet(option=leafletOptions(zoomControl= FALSE, minZoom = 2, maxZoom = 12)) %>% addProviderTiles(providers$CartoDB.Positron) %>% 
  addPolygons(data = la_shrink, fillColor = 'transparent', color = 'red', weight = 4) %>% 
  addPolygons(data = la,fillColor = col, color = col1, weight = 4)
```

Now that you know what it takes to define an AOI covering any region you want, take a look at the [AOI Tools](./docs/articles/tools.html) page to learn how to define, refine, manipulate, and describe your extents! Be sure to also check out the AOI package in action on [use cases](./doc/articles/useCases.html) page. 


